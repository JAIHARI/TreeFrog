# An example configuration file for TreeFrog

# The default set in this file are the most optimal parameters but these may be different depending on the situation 
# The parameters also vary depending on the type of tree that is being built, in these cases the defaults are stated in the comments

############################################################################
# Input related
############################################################################

# Format of the input trees Sussing 1, normal velociraptor catalog 2, nIFTY 3, Void 4 
Input_tree_format = 2


############################################################################
#  Input modifiers for normal catalog produced by velociraptor 
############################################################################

# Input format if it is in binary 1, hdf 2, or ascii 0
Input_format = 2

# If field objects have been put into a seprate file (Separate_output_files=1 in the VELOCIraptor configuration)
Field_sep_files = 0

# If output is split between multiple files due to VELOIraptor been run with mpi, number of files written (Change this to a simple flag if it has been run with MPI or not?)
Num_files_per_snap = 12


############################################################################
# Output related
############################################################################

# Output format (ASCII 0, HDF5 2)
Output_format = 2

# The amount of data to be outputted, 0 for minimal, 1 for outputing merits as well, 2 for outputing number of particles in halos
Output_data_format = 1

############################################################################
# ID related options
############################################################################

# The maximum ID value for particles. THIS MUST BE SPECIFIED IF NOT MAPPING IDS TO INDEX
Max_ID_Value = 134217728 #(512^3)

# The mapping of particles to index. Possibilities are: 
# 0 no mapping
# 1 simple mapping
# -1 computationally intensive but memory efficent mapping
Mapping = 0


############################################################################
# Catalogue type related
############################################################################

# Type of catalogue to be produced (0 halo tree ,1 cross catalog ,2 full graph)
Catalogue_type = 0


############################################################################
# Tree construction options
############################################################################

# The direction in which the tree is to be built. Possibilities are: 0 progenitor, 1 descendant, -1 both directions
Tree_direction = 0

# Type of particles to cross correlate. Possibilities are: -1 all particle types, 1 DM particle types, 0 GAS particle type, 4 STAR particle type, -2 both DM and GAS particle type
Part_type = -1

# The number of steps intergrated over to try and find better links
Nsteps_search_new_links = 1

# If you want the rest of the Tree Construction options to be the defualt (optimal values), please switch this value on and comment out the rest of the Tree constuction options below. 0 = Off, 1 = On
Default_values = 1

# Cross correlation function type to identify main progenitor/descendant/link. Possibilities are:
# 1 standard merit: Nshared^2/N1/N2
# 2 fraction merit: Nshared/N1
# 3 shared merit of Nshared
# 4 shared combo merit: Nshared/N1 * (1+Nshared/N2)
# 5 rank weighted merit (for descendant based tree): Nshared^2/N1/N2 * ranksum / norm 
#	where ranksum is the ranking is based on Poole+ 2017 where the most bound particles are ranked higher in the shared particle list, this assumes input particle list is meaningful (either boundness ranked or radially for example)
#	norm is the normalisation to the optimal value for nsh=n2, for all particles in the descendant
# 6 rank weighted merit both this is the same as 5, but the ranking is done both ways so normalised to both optimal value for nsh=n2 and nsh=n1: Nshared^2/N1/N2 * ranksum / norm1 * ranksum / norm2 
# Defualt, 1 for progenitor based tree and 6 for descendant based tree
Merit_type = 1

# If the cores of the halos are also to be used in the halo cross match. Possibilities are:
# 0 no core matching refinement
# 1 for descendant tree, identify initial links using core of current halo and all particles with biased Nsh^2/N1/N2 merit of other haloes followed by core-core with unbiased Nsh^2/N1/N2 merit. 
#	For progenitor tree, does core to all with unbiased Nsh^2/N1/N2 merit.
# 2 for descendant and progenitor trees, does normal all to all particle match followed by a core-to-core match with unbiased merits.
# 3 using only a core-core match.
# Default, 2 for progenitor based tree and 1 for descendant based tree
Core_match_type = 2

# Fraction of particles to use in the halo core cross match
Particle_core_fraction = 0.4

# Minimum number of particles to have as core particles
# Default, 20 for progenitor based tree and 5 for descendant based tree
Particle_core_min_numpart = 20

# Criteria for when to keep searching for new links if linking is to be done over multiple snapshots. Possibilities are: 
# 0 only if link is missing
# 1 missing & low merit given by merit limit
# 2 missing & or low ranking descendant when constructing descendant tree
# 3 missing & low merit & or low ranking descendant when constructing descendant tree
# Default, 0 for progenitor based tree and 3 for descendant based tree
Multistep_linking_criterion = 0

# Merit limit to search for new links
Merit_limit_continuing_search = 0.05

# Use a temporally weighted merit so preferentially chooses objects which are closer in time. Possibilities are: 
# 0 simple temporal merit where the merit is weighted by 1/deltat^ALPHADELTAT where ALPHADELTAT is 0.12
# 1 the same weighting as 0 but also using if the halo is a primary progenitor in the snapshots before in the case of the progenitor based tree 
#	or is a primary descendant in the snapshots after in the case of the descendant based tree
# Default, 0 for progenitor based tree and 1 for descendant based tree
Temporal_merit_type = 0

# When comparing if a halo has 2 matches to halos that already have their direct progenitors set, how larger of a merit ratio is needed to switch the connection of the halo it has merged with
# Default, 4.0 for progenitor based tree and 5.0 for descendant based tree
Merit_ratio_limit = 4.0

# Significance of cross match relative to Poisson noise
Shared_particle_signal_to_noise_limit = 0.1


############################################################################
# Output halo ID related options
############################################################################

# Adjust Halo ID values stored in group catalog, useful for matching these values to those stored in .properties files produced by the halo finder. output is ID+(snap+HaloID_snapshot_offset)*haloIDval
Temporal_haloidval = 0

# Adjust Halo ID by this offset value 
HaloID_offset = 0

# Offset snapshot values of haloIDs by this number, this needs to be given if not starting at snapshot 0
HaloID_snapshot_offset = 0

############################################################################
# MPI load balancing options
############################################################################

# Number of items per mpi thead, use for load balacing. If 0, based on input
Num_per_mpi = 0

# Number of mpi theads used to calculate load balacing. If >0 this used with one actual mpi thread but determines load balancing based on desired number of mpi threads. Write load balancing file and terminates. If 0 (default) normal operation 
Num_desired_mpi_threads = 0

# Whether to write output in parallel, 0 no or 1 yes
Write_parallel = 0

# How the files are split across MPI threads, 1 for halo based splitting, 0 for particle based splitting.
Mpi_load_balance_splitting = 1

############################################################################
# Other options
############################################################################

# How talkative do you want the code to be, 0 not much, 1 a lot, 2 chatterbox
Verbose = 1